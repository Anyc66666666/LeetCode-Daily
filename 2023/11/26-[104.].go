package leetcode

//ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ root ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚
//
// äºŒå‰æ ‘çš„ æœ€å¤§æ·±åº¦ æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚
//
//
//
// ç¤ºä¾‹ 1ï¼š
//
//
//
//
//
//
//è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
//è¾“å‡ºï¼š3
//
//
// ç¤ºä¾‹ 2ï¼š
//
//
//è¾“å…¥ï¼šroot = [1,null,2]
//è¾“å‡ºï¼š2
//
//
//
//
// æç¤ºï¼š
//
//
// æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡åœ¨ [0, 10â´] åŒºé—´å†…ã€‚
// -100 <= Node.val <= 100
//
//
// Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 1745 ğŸ‘ 0

//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

//	type TreeNode struct {
//		    Val int
//		    Left *TreeNode
//		    Right *TreeNode
//		}
func maxDepth(root *TreeNode) int {
	if root == nil {
		return 0
	}
	var ans int
	var dfs func(node *TreeNode, depth int)
	depth := 0
	dfs = func(node *TreeNode, depth int) {
		if node == nil {
			return
		}
		if depth > ans {
			ans = depth
		}
		dfs(node.Left, depth+1)
		dfs(node.Right, depth+1)
	}
	dfs(root, depth)
	return ans + 1
}

//leetcode submit region end(Prohibit modification and deletion)
